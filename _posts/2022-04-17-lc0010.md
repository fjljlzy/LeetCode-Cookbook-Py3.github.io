---
layout:     post
title:      LeetCode 10. 正则表达式匹配  (Python3)  
number:     10               
level:      Hard        #难度 Easy, Medium, Hard
lcurl:      regular-expression-matching        #子url
youtube:                    #略
bilibili1:                  #略
xigua:                      #略
date:       2022-04-17                #解题时间
author:     fjljlzy
header-img: img/post-bg-coffee.jpeg
catalog: false
tags: 
    #标签 
    - 动态规划
---
# 题目大意：
$$$$
给定两个字符串 s 和 p，其中 s 代表需要进行判断的字符串（string），p 代表蕴含某种特殊规律的模式串（pattern），判断 p 是否能匹配 s。

模式串中有两个特殊通配字符，

- $$"\cdot"$$ 匹配任意单个字符
- $$"*"$$ 匹配零个或多个前面的那一个元素

题外话：pattern 可以指代在数据中含有的某种模式、结构、知识等。机器学习领域早年的一个叫法就是模式识别（Pattern Recognition），著名的机器学习图像领域的顶会 CVPR 的全称是 Computer Vision and Pattern Recognition。

举例来直观理解 s 和 p：
- 模式串 p 为 $$a*$$，可以匹配所有以 a 开头，后续任意多位都是 a 的字符串 s： a, aa, aaa, aaaa ...
- 模式串 p 为 $$a.$$，可以匹配所有以 a 开头，后续一位是任意字符的字符串 s： aa, ab, ac, ad ...
- 模式串 p 为 $$a.*b$$，可以匹配所有以 a 开头，以 b 结尾，中间是任意字符的字符串 s： ab, acb, acdb, azzzzb, ...

### 思路：

我们已经简单了解了 $$"\cdot"$$ 和 $$"*"$$ 的作用。$$"\cdot"$$ 的功能是容易编码实现的，这就是个万能匹配的字符。而对于 $$"*"$$，这个通配符**不仅有批量复制前一个字符的作用，还有取消前一个字符的作用**，实现起来似乎颇有难度。

例如，$$a*$$ 既可以匹配 a, aa, aaa, aaaa，又可以匹配空字符串（0个a）。因此，模式串 $$a*b$$ 既可以匹配目标串 $$aaaab$$，也能匹配 $$b$$。

那么，该如何代码实现上述的功能呢？我们选择动态规划作为工具进行分析。

一、状态定义：取 i 遍历 s 中的每一个位置，取 j 遍历 p 中的每一个位置，建立二维数组 dp[i][j]。dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符能否匹配。

二、状态转移：自行选择一个测试案例，比如这里选择 aa 为目标串，a* 为模式串为例，建立 dp 数组的横纵坐标，从左上角开始填值，尝试在填值过程思考状态转移过程。

- 下面的 dp 数组，row index 代表目标串s，s[i] 代表第 i 位字符，column index 代表模式串 p，p[j] 代表第 j 位字符。由于动态规划的常见转移过程都和前一位有关，为了防止数组出现越界错误，在 s 和 p 前面各加入 # 字符，代表空字符。


|   | # | a | * |
|---|---|---|---|
| # |   |   |   |
| a |   |   |   |
| a |   |   |   |


- 填初始值（即第一行和第一列的值）

|   | # | a | * |
|---|---|---|---|
| # | T  | F  | ?  |
| a | F  |   |   |
| a | F  |   |   |

当 dp[i][j] 位于问号处，此时 p[j] 为 * ，且 dp[i][j - 2] = True （因为 # 和 # 匹配，这毫无疑问），此时我们可以推断 dp[i][j] = True （因为 # 和 # 匹配，# 和 # a* 也是匹配的，a* 代表 0 个 a），此时 * 的作用是消除前一个字符 a。

- 继续填值，从已填的值推导出未填的值

|   | # | a | * |
|---|---|---|---|
| # | T  | F  | T |
| a | F  | ?  |   |
| a | F  |   |   |

当 dp[i][j] 位于问号处，此时 p[j] 为 普通字符 ，易得 dp[i][j] = dp[i - 1][j - 1] & s[i] == p[j] 

- 继续填值，从已填的值推导出未填的值

|   | # | a | * |
|---|---|---|---|
| # | T  | F  | T |
| a | F  | T  | ?  |
| a | F  |   |   |

当 dp[i][j] 位于问号处，此时 p[j] 为 * ，我们发现dp[i][j - 1] 为 True，说明 s(#a) 和 p(#a) 匹配，因此可推断 s(#a) 和 p(#a*) 匹配，此时 * 的作用是只保留 1 个前一个字符 a。

- 继续填值，从已填的值推导出未填的值

|   | # | a | * |
|---|---|---|---|
| # | T  | F  | T |
| a | F  | T  | T  |
| a | F  | F | ?  |

当 dp[i][j] 位于问号处，此时 p[j] 为 * ，我们发现 dp[i][j - 1] 为 False（说明 s(#aa) 和 p(#a) 不匹配），发现 dp[i][j - 2] 为 False（说明 s(#aa) 和 p(#) 不匹配），但我们发现 dp[i - 1][j] 为 True（说明 s(#a) 和 p(#a*) 匹配），由于 s[i] = p[j - 1] (说明 s的下一位和 p 的待复制位相同)，因此推断出 s(#aa) 和 p(#a*) 匹配。如果这里 s 的下一位是 b 而非 a，那就推断出不匹配。

有点绕？一句话总结，

若已知 s(#a) 和 p(#a*) 匹配，那么 s(#aa) 和 p(#a*) 匹配，因为 s 多出来的这一位字符，恰好是 p 的待复制的字符。

同理，

若已知 s(#a) 和 p(#a*) 匹配，那么 s(#ab) 和 p(#a*) 不匹配，因为 s 多出来的这一位字符，并不是 p 的待复制的字符。

- 写完 dp数组 的填表过程，总结写表过程中发现的规律 

|   | # | a | * |
|---|---|---|---|
| # | T  | F  | T |
| a | F  | T  | T  |
| a | F  | F | T  |


1. **看左上格**：若 p[j] 为 普通字符，dp[i][j] = (dp[i - 1][j - 1] && s[i] == p[j])
2. **看左上格**：若 p[j] 为 $$"\cdot"$$，dp[i][j] = (dp[i - 1][j - 1] && s[i] == p[j])，因为 s[i] 和 p[j] 一定相等（因为 $$"\cdot"$$ 一定匹配，所以 dp[i][j] = dp[i - 1][j - 1] 
3. **看左1格，看左2格，看上格**：若 p[j] 为 $$"*"$$，
- 检查 dp[i][j - 1], 若为True，则 dp[i][j] 为 True;
- 检查 dp[i][j - 2], 若为True，则 dp[i][j] 为 True;
- 检查 dp[i - 1][j], 若为True，若 s[i] == p[j - 1]，说明 s 多出来的这一位字符，恰好是 p 的待复制的字符，则 dp[i][j] 为 True。否则皆认为不匹配。注意这里判断 s[i] == p[j - 1]，要加入对 $$"\cdot"$$ 的考虑。


最后，整理上述思路，变成最后代码。

### 代码：
```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        dp = [[False for _ in range(len(p) + 1)] for _ in range(len(s) + 1)]
        dp[0][0] = True
        s = '#' + s
        p = '#' + p
        for i in range(0, len(dp)):
            for j in range(1, len(dp[0])):
                if p[j] == '.':
                    dp[i][j] = dp[i - 1][j - 1]
                elif p[j] == '*':
                    if dp[i][j - 2] or dp[i][j - 1]:
                        dp[i][j] = True
                    elif dp[i - 1][j] and (s[i] == p[j - 1] or p[j - 1] == '.'):
                        dp[i][j] = True
                    else: 
                        dp[i][j] = False
                else:
                    dp[i][j] = (dp[i - 1][j - 1] and s[i] == p[j])
        return dp[-1][-1]
```