---
layout:     post
title:      LeetCode 4. 寻找两个正序数组的中位数  (Python3)  
number:     4               
level:      Hard        #难度 Easy, Medium, Hard
lcurl:      median-of-two-sorted-arrays        #子url
youtube:                    #略
bilibili1:                  #略
xigua:                      #略
date:       2022-04-10                #解题时间
author:     fjljlzy
header-img: img/post-bg-coffee.jpeg
catalog: false
tags: 
    #标签 
    - 二分查找
---
# 题目大意：
$$$$
给定两个排序好的数组，如果将两个数组组合为一个数组，可获得合并后数组的中位数。如何充分利用这个条件，是解题的关键。


#### 暴力思路：
几乎秒想的方法，可以直接将两个数组合并后排序取中点，适合太紧张或者想不明白二分查找的时候，可以挽救一下面试官的印象分。既然用了这么无脑的方法，排序还是手动实现个快速排序或者归并排序。注意这里最好使用归并排序，因为两个数组均是有序的，只需要完成归并排序的 merge 部分即可。

#### 最佳思路：二分查找
中位数可以认为是在一个排好序的数组中找第 k 小和第 k 大的数， k 的值为数组长度除以2。若arr = [1,2,3,4,5,6]，那么中位数就由第3小和第3大的两个数字3和4的得到，即$$(3+4)/2 = 3.5$$。若arr = [1,2,3,4,5]，则该数组的中位数为$$(3+3)/2 = 3$$.

那么如何在两个增序数组中找到第k小的数呢？首先在nums1取前 k/2 个数，在nums2上也取前 k/2 个数，比较 nums1[k/2] 和 nums2[k/2] 的大小。在 nums1 中有 k/2 个数小于等于 nums1[k/2]，在 nums2 中有 k/2 个数小于等于 nums2[k/2] 



例如：\\
nums1 = [2,4] \\
nums2 = [1,3,5,6] \\
合并后的 nums = [1,2,3,4,5,6]\\
若k=1，找第一小的数，比较nums1[0]和nums2[0]取最小值。\\
若k=2，找第二小的数，则在nums1取第 k / 2 个数，在nums2上也取第 k / 2 个数，比较这两个数，发现nums1[0]和 nums2[0] 中 nums2[0]更小，说明 nums2[0] 一定不是第二小的数，

回到原问题，我们已知两个数组 nums1 和 nums2，其长度分别为 m 和 n，那么我们现在的目的是找到第k小的数

#### 代码1：暴力法（归并）
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        nums = []
        i, j = 0, 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] < nums2[j]:
                nums.append(nums1[i])
                i += 1
            else:
                nums.append(nums2[j])
                j += 1
        if i < len(nums1):
            nums += nums1[i:]
        else:
            nums += nums2[j:]

        mid = len(nums) // 2
        if len(nums) % 2 == 0:
            return (nums[mid] + nums[mid - 1]) / 2
        else:
            return nums[mid]
```

#### 代码2：暴力法（快排） 
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def quickSort(arr, l, r):
            if l >= r:
                return
            # change pivot
            idx = (l + r) // 2
            arr[idx], arr[l] = arr[l], arr[idx]

            i, j = l, r
            while i < j:
                while i < j and arr[j] > arr[l]:
                    j -= 1
                while i < j and arr[i] <= arr[l]:
                    i += 1
                arr[i], arr[j] = arr[j], arr[i]
            arr[i], arr[l] = arr[l], arr[i]

            quickSort(arr, l, i - 1)
            quickSort(arr, j + 1, r)
        merge_nums = nums1 + nums2
        quickSort(merge_nums, 0, len(merge_nums) - 1)
        
        mid = len(merge_nums) // 2
        if len(merge_nums) % 2 == 0:
            return (merge_nums[mid] + merge_nums[mid - 1]) / 2
        else:
            return merge_nums[mid]
```
